---
title: 包管理工具
categories: 前端
tags:
  - JavaScript
---

**文章目录**
[[toc]]

## 简介
前端的包管理工具至写这篇文章为止，主要是 npm 和 yarn，当然还有其他的 pnpm、Tlink 等
这篇文章主要讲 npm 和 yarn 这两个管理工具的区别



## npm 管理工具

这里的部分引用于https://juejin.im/post/6844903601563762702

### 上古时代

在上古版本(应该是 npm3 以前的版本，具体我也记不清了)，npm 的安装策略并不是扁平化的，也就是说比如你安装一个 `express`，那么你会在 `node_modules` 下面只找到一个 `express` 的文件夹。而 `express` 依赖的项目都放在其文件夹下。

```plain
- app/
  - package.json
  - node_modules/
    - express/
      - index.js
      - package.json
      - node_modules/
        - ...
```

这个带来的问题或许 windows 用户深谙其痛，因为在这种安装环境下，会导致目录的层级特别高，而对于 windows 来说，最大的路径长度限制在 248 个字符([更多请见此](https://www.cnblogs.com/52cik/p/node-modules-del.html))，再加上 `node_modules` 这个单词又特别长，所以你懂得，哈哈哈。解决方案啥的自己去搜索吧，反正估计现在也没人会用上古版本了。

上古时代的 npm 的缺点可以说还是很多的：

- 目录嵌套层级过深
- 模块实例无法共享
- 安装速度很慢，这其中有目录嵌套的原因，也有安装逻辑的问题。因为 npm 是请求完一个模块之后再去请求另一个模块，这就会导致同一个时刻，只有一个模块在下载、解析、安装。



### 软链时代

后面，有人为了解决目录嵌套层次过高的问题，引入的软链接的方案。

简单来说，就是将所有的包都扁平化安装到一个位置，然后通过软链接(windows 快捷方式)的方式组合到 `node_modules` 中。

```plain
- app/
- node_modules
  - .modules/
    - express@x.x.x/
      - node_modules
        - connect -> ../../connect@x.x.x
        - path-to-regexp -> ../../path-to-regexp@x.x.x
        - ... -> ../../package-name@x.x.x
    - connect@x.x.x/
    - path-to-regexp@x.x.x/
    - ...others
  - express -> ./.modules/express@x.x.x
```

这样做的好处就是可以将整体的逻辑层级简化到很少的几层。而且对于 node 的模块解析来说，可以很好的解决相同模块不同位置导致的加载多个实例，进而导致内存占用的情况。

基于这种方案，有 [npminstall](https://www.npmjs.com/package/npminstall) 以及 pnpm 这个包实现了这种方案，其中 cnpm 使用的就是 npminstall，不过他们实现的方式和我上面讲的是有差异的，[具体请看](https://www.npmjs.com/package/npminstall#node_modules-directory)。简单来讲，他们没有 `.modules` 这一层。更多的内容，请看 npminstall 的 README。

总的来讲这种解决方案有还有以下几个好处：

- 兼容性很好
- 在保证目录足够简洁的情况下，解决了上面的两个问题（目录嵌套和多实例加载）。
- 安装速度很快，因为采用了软连接的方式加上多线程请求，多个模块同时下载、解析、安装。

那么缺点也是挺致命的：

- 一般情况下都是第三方库实现这个功能，所以无法保证和 npm 完全一致的行为，所以遇到问题只能去找作者提交一下，然后等待修复。
- 无法和 npm 很方便的一起使用。最好是要么只用 npm，要么只用 cnpm/pnpm，两者混用可能会产生很奇葩的效果。



## npm3 时代

最大的改变就是将目录层级从嵌套变到扁平化，可以说很好的解决了上面嵌套层级过深以及实例不共享的问题。但是，npm3 在扁平化方案下，选择的并不是软连接的方式，而是说直接将所有模块都安装到 `node_modules` 下面。

```plain
- app/
- node_modules/
  - express/
  - connect/
  - path-to-regexp/
  - ...
```

如果出现了不同版本的依赖，比如说 `package-a` 依赖 `package-c@0.x.x` 的版本，而 `package-b` 依赖 `package-c@1.x.x` 版本，那么解决方案还是像之前的那种嵌套模式一样。

```plain
- app/
- node_modules/
  - package-a/
  - package-c/
    - // 0.x.x
  - package-b/
    - node_modules/
      - package-c/
        - // 1.x.x
```

至于那个版本在外面，那个版本在里面，似乎是根据安装的先后顺序有关的，具体的我就不验证了。如果有人知道的话，欢迎告诉我。

在这个版本之后，解决了大部分问题，可以说 npm 跨入了一个新的世界。但是还要一个问题就是，他的安装速度依旧很慢，相比 cnpm 来说。所以他还有很多进步的空间。

## yarn 管理工具

### yarn 的简介

Yarn 就是一个类似于 npm 的包管理工具，它是由 facebook 推出并开源。

在 yarn 出来之前，npm 有着很多难以忍受的诟病，比如：
1. npm 安装包（packages）的速度不够快，拉取的 packages 可能版本不同，很大可能出现在我的电脑上可以但是在你的电脑上不行，因为两个电脑下载的包的版本都是不一样的。

   其实 npm 是有解决方案的，为了解决这个问题，npm 提供了[shrinkwrap](https://docs.npmjs.com/cli/shrinkwrap)命令。此命令将生成一个 npm-shrinkwrap.json 文件，为所有库和所有嵌套依赖的库记录确切的版本。然而，即使存在**npm-shrinkwrap.json**这个文件，npm 也只会锁定库的版本，而不是库的内容。即便 npm 现在也能阻止用户多次重复发布库的同一版本，但是 npm 管理员仍然具有强制更新某些库的权力。

   虽然大家都知道 npm 通过语义化的版本号安装应用，你可以限制你安装模块的版本号，但是你无法限制你安装模块依赖的模块的版本号。即使有 `shrinkwrap` 的存在，但是很少有人会用。通俗的说，就算你知道`shrinkwrap`这个命令去限定版本，但是你所安装的那个库的开发者他并不一定知道

2. 比如 npm 允许在安装 packages 时执行代码，这就埋下了安全隐患。

3. npm 不支持离线模式，如果公司的网络不支持连接外网，这个时候利用缓存构建应用就是很方便的一件事情。而且可以大大减少网络请求。

4. 最严重的一点就是安装速度特别的慢



在这个背景下 yarn 诞生了，为解决如上的问题，如下：

- 速度快:npm 会等一个包完全安装完才跳到下一个包，但 yarn 会并行执行包，因此速度会快很多。

  Yarn 会缓存它下载的每个包，所以无需重复下载。它还能并行化操作以最大化资源利用率，安装速度之快前所未有。

- 离线模式:之前安装过的包会被保存进缓存目录，以后安装就直接从缓存中复制过来，这样做的本质还是会提高安装下载的速度，避免不必要的网络请求。
- 可靠确定:通过 yarn.lock 文件来管理依赖版本问题，保证每次安装都是一致的。
- 网络优化:力求网络资源最大利用化，让资源下载完美队列执行，避免大量的无用请求，下载失败会自动重新请求，避免整个安装过程失败
- 扁平化模式:对于不匹配的依赖版本的包创立一个独立的包，避免创建重复的。对于多个包依赖同一个子包的情况，yarn 会尽量提取为同一个包，防止出现多处副本，浪费空间。
- 版本控制:使用了 yarn 之后，可以完美的解决 npm 下载包不准确的问题，即便 npm 有 npm-shrinkwrap 来保证版本固定，但这个不是 npm 的标配，很多人都不知道这个命令，而 yarn 可以下载的时候就已经固化版本了。yarn 会生成一个类似 **npm-shrinkwrap.json** 的 **yarn.lock** 文件，而文件内会描述包自身的版本号，还会锁定所有它依赖的包的版本号。yarn.lock 存储着你的每个包的确切依赖版本，能确保从本地开发到生产环境，所有机器上都有精确相同的依赖版本。

- 默认情况安装会保存到 dependencies，不需要像 npm 一样手动添加 `-S` 参数
- 非常方便的 yarn run 命令，不仅仅会自动查看 package.json 中 scripts 下面的内容，还是查找 `node_modules/.bin` 下的可执行文件。这个是我用 yarn 最高的频率。比如你安装了 `yarn add mocha`，然后就可以通过 `yarn run mocha` 直接运行 `mocha`。而不需要 `./node_modules/.bin/mocha` 运行。
- 交互式的版本依赖更新。npm 你只能先通过 `npm outdated` 看看那些包需要更新，然后通过 `npm update [packages]` 更新指定的包。而在 yarn 当中，可以通过交互式的方式，来选择那些需要更新，那些不需要。
- 全局模块的管理。npm 管理全局模块的方式是通过直接在 `/usr/lib/node_modules` 下面安装，然后通过软连接连接到 `/usr/local/bin` 目录下。而 yarn 的做法是选择一个目录，这个目录就是全局模块安装的地方，然后将所有的全局模块当做一个项目，从而进行管理。这个好处就是，你可以直接备份这个目录当中的 package.json 和 yarn.lock 文件，从而可以很方便的在另一个地方还原你安装了那些全局模块。至于这个目录的问题，通过 `yarn global dir` 命令就可以找到，mac 下是在 `~/.config/yarn/global/`，linux 我没有测试过。



## npm 的弥补

受到 yarn 带来的压力后，npm 也做出了补救的措施，比如在 npm5 的补救措施，如下:

1. 引入了 package-lock.json，并且默认就会添加，和 yarn.lock 是一样的作用，并且取代之前的 npm shrinkwrap。
2. 默认情况下，安装会自动添加 dependencies，不需要手动书写 `-S` 参数
3. 提升了安装速度，和之前有了很大的进步，但是和 yarn 相比，还是略微慢一些



npm 和 yarn 的下载速度对比也是差不多的了，以及后来的 npx 命令来对比 yarn run 命令，`npm-check` 这个工具，可以用来替代 yarn 的交互式更新，以及 npm6 的增加缓存来提升下载速度



## npm 的语义化

最后这里再讲一下 npm 包管理的语义化

npm 的管理模式一般为**主版本号.次版本号.修订号**

不同版本号递增规则如下：

- **主版本号(major)**：当你做了不兼容的 API 修改(大版本修改)
- **次版本号(minor)**：当你做了向下兼容的功能性新增，可以理解为 Feature 版本
- **修订号(patch)**：当你做了向下兼容的问题修正，可以理解为 Bug fix 版本

## 各种版本限定

- **指定版本**：比如 1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。
- **波浪号（tilde）+指定版本**：比如~1.2.2，表示安装 1.2.x 的最新版本（不低于 1.2.2），但是不安装 1.3.x，也就是说安装时不改变大版本号和次要版本号。
- **插入号（caret）+指定版本**：比如ˆ1.2.2，表示安装 1.x.x 的最新版本（不低于 1.2.2），但是不安装 2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为 0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。
- **latest**：安装最新版本。

参考文章：
> https://juejin.im/post/6844903601563762702
>
> https://zhuanlan.zhihu.com/p/66039729
>
> https://juejin.im/post/6844903616109641736
>
> https://neveryu.github.io/2018/07/20/yarn/
>
> https://www.jianshu.com/p/7d83bda6d751