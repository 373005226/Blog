---
title: XSS 攻击
categories: 前端
tags:
  - Web 安全
---

## Cookie

跨站脚本攻击（Cross Site Scripting）本来的缩写为 CSS，为了与层叠样式表（Cascading Style Sheets，CSS）的缩写进行区分，将跨站脚本攻击缩写为 XSS。因此 XSS 是跨站脚本的意思。

XSS 跨站脚本攻击（Cross Site Scripting），的本质是攻击者在 web 页面插入恶意的 script 代码（这个代码可以是 JS 脚本、CSS 样式或者其他意料之外的代码），当用户浏览该页面之时，嵌入其中的 script 代码会被执行，从而达到恶意攻击用户的目的。比如读取 cookie，session，tokens，或者网站其他敏感的网站信息，对用户进行钓鱼欺诈等。

### XSS 攻击的危害

* 通过 document.cookie 盗取 cookie 中的信息

* 流量劫持(通过访问某段具有 window.location.href 定位到其他页面）

* dos 攻击通过携带过程的 cookie 信息可以使服务端返回 400 开头的状态码，从而拒绝合理的请求服务。

* 利用得到的 cookie 用户信息去执行一些操作

### 反射型 XSS 攻击

通俗的说就是拿到用户的 cookie 发送到攻击者的网站或者是冒充用户的行为去执行指定的操作

对于这种攻击可以对输入进行检查或者是对输出的代码进行转义的显示（比如说对查询的参数进行编码）

### 存储型 XSS 攻击

这个是将恶意代码放到目标网站的数据库中，然后打开目标网站就会把恶意代码取出拼接 HTML 给浏览器，那么浏览器就会把这个恶意代码对每一个访问用户执行

对于这种情况也是需要根上面反射型一样预防

1. 请求接口之前先对参数进行转义和过滤掉危险代码

2. 显示服务端接口数据的时候进行转义和过滤代码

## 其他防范措施

在 Chrome 80 版本后 将 Cookie 的跨站策略（SameSite）默认设置为了 Lax，即仅允许同站或者子站访问 Cookie，而老版本是 None，即允许所有跨站 Cookie，这样虽然是避免了 XSS 攻击，但是也会让用户在访问 `A.com` 网站的时候，`B.com` 的网站无法获取到，无法达到获取第三方 cookie 的目的，要解决的话，在返回请求的 header 里将 `SameSite` 设置为 None 即可

此外在 cookie 有两个属性，`Secure` 和 `HttpOnly` 

1. 其中 Secure 是只允许 Cookie 在 HTTPS 请求中被使用

2. HttpOnly 则用来禁止使用 JS 访问 cookie

就目前而言，应对 XSS 攻击的主要手段还是编码与过滤两种，编码用于将特殊的符号 "`<`、`>`、`&`、`、`进行 html 转义，而过滤则是阻止特定的标记、属性、事件。如果你不愿意为了严格的安全而限制产品本身的灵活，那么我更建议采用“编码”的方案。
